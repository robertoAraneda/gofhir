// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (backbone elements)
// Package: r5

package r5

// ConceptMapAdditionalAttribute represents the ConceptMap.additionalAttribute backbone element.
// Definition of an additional attribute to act as a data source or target
type ConceptMapAdditionalAttribute struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifies this additional attribute through this resource
	Code *string `json:"code,omitempty"`
	// Formal identifier for the data element referred to in this attribte
	Uri *string `json:"uri,omitempty"`
	// Why the additional attribute is defined, and/or what the data element it refers to is
	Description *string `json:"description,omitempty"`
	// code | Coding | string | boolean | Quantity
	Type *ConceptMapAttributeType `json:"type,omitempty"`
}

// ConceptMapGroup represents the ConceptMap.group backbone element.
// Same source and target systems
type ConceptMapGroup struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Source system where concepts to be mapped are defined
	Source *string `json:"source,omitempty"`
	// Target system that the concepts are to be mapped to
	Target *string `json:"target,omitempty"`
	// Mappings for a concept from the source set
	Element []ConceptMapGroupElement `json:"element,omitempty"`
	// What to do when there is no mapping target for the source concept and ConceptMap.group.element.noMap is not true
	Unmapped *ConceptMapGroupUnmapped `json:"unmapped,omitempty"`
}

// ConceptMapGroupElement represents the ConceptMap.group.element backbone element.
// Mappings for a concept from the source set
type ConceptMapGroupElement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifies element being mapped
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// Identifies the set of concepts being mapped
	ValueSet *string `json:"valueSet,omitempty"`
	// No mapping to a target concept for this source concept
	NoMap *bool `json:"noMap,omitempty"`
	// Concept in target system for element
	Target []ConceptMapGroupElementTarget `json:"target,omitempty"`
}

// ConceptMapGroupElementTarget represents the ConceptMap.group.element.target backbone element.
// Concept in target system for element
type ConceptMapGroupElementTarget struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code that identifies the target element
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// Identifies the set of target concepts
	ValueSet *string `json:"valueSet,omitempty"`
	// related-to | equivalent | source-is-narrower-than-target | source-is-broader-than-target | not-related-to
	Relationship *ConceptMapRelationship `json:"relationship,omitempty"`
	// Description of status/issues in mapping
	Comment *string `json:"comment,omitempty"`
	// Property value for the source -> target mapping
	Property []ConceptMapGroupElementTargetProperty `json:"property,omitempty"`
	// Other properties required for this mapping
	DependsOn []ConceptMapGroupElementTargetDependsOn `json:"dependsOn,omitempty"`
	// Other data elements that this mapping also produces
	Product []ConceptMapGroupElementTargetDependsOn `json:"product,omitempty"`
}

// ConceptMapGroupElementTargetDependsOn represents the ConceptMap.group.element.target.dependsOn backbone element.
// Other properties required for this mapping
type ConceptMapGroupElementTargetDependsOn struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// A reference to a mapping attribute defined in ConceptMap.additionalAttribute
	Attribute *string `json:"attribute,omitempty"`
	// Value of the referenced data element
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// Value of the referenced data element
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of the referenced data element
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of the referenced data element
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of the referenced data element
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// The mapping depends on a data element with a value from this value set
	ValueSet *string `json:"valueSet,omitempty"`
}

// ConceptMapGroupElementTargetProperty represents the ConceptMap.group.element.target.property backbone element.
// Property value for the source -> target mapping
type ConceptMapGroupElementTargetProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to ConceptMap.property.code
	Code *string `json:"code,omitempty"`
	// Value of the property for this concept
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of the property for this concept
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of the property for this concept
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of the property for this concept
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of the property for this concept
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Value of the property for this concept
	ValueDecimal *float64 `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Value of the property for this concept
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
}

// ConceptMapGroupUnmapped represents the ConceptMap.group.unmapped backbone element.
// What to do when there is no mapping target for the source concept and ConceptMap.group.element.noMap is not true
type ConceptMapGroupUnmapped struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// use-source-code | fixed | other-map
	Mode *ConceptMapGroupUnmappedMode `json:"mode,omitempty"`
	// Fixed code when mode = fixed
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// Fixed code set when mode = fixed
	ValueSet *string `json:"valueSet,omitempty"`
	// related-to | equivalent | source-is-narrower-than-target | source-is-broader-than-target | not-related-to
	Relationship *ConceptMapRelationship `json:"relationship,omitempty"`
	// canonical reference to an additional ConceptMap to use for mapping if the source concept is unmapped
	OtherMap *string `json:"otherMap,omitempty"`
}

// ConceptMapProperty represents the ConceptMap.property backbone element.
// Additional properties of the mapping
type ConceptMapProperty struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifies the property on the mappings, and when referred to in the $translate operation
	Code *string `json:"code,omitempty"`
	// Formal identifier for the property
	Uri *string `json:"uri,omitempty"`
	// Why the property is defined, and/or what it conveys
	Description *string `json:"description,omitempty"`
	// Coding | string | integer | boolean | dateTime | decimal | code
	Type *ConceptMapPropertyType `json:"type,omitempty"`
	// The CodeSystem from which code values come
	System *string `json:"system,omitempty"`
}
