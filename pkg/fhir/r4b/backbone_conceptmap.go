// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (backbone elements)
// Package: r4b

package r4b

// ConceptMapGroup represents the ConceptMap.group backbone element.
// Same source and target systems
type ConceptMapGroup struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Source system where concepts to be mapped are defined
	Source *string `json:"source,omitempty"`
	// Specific version of the  code system
	SourceVersion *string `json:"sourceVersion,omitempty"`
	// Target system that the concepts are to be mapped to
	Target *string `json:"target,omitempty"`
	// Specific version of the  code system
	TargetVersion *string `json:"targetVersion,omitempty"`
	// Mappings for a concept from the source set
	Element []ConceptMapGroupElement `json:"element,omitempty"`
	// What to do when there is no mapping for the source concept
	Unmapped *ConceptMapGroupUnmapped `json:"unmapped,omitempty"`
}

// ConceptMapGroupElement represents the ConceptMap.group.element backbone element.
// Mappings for a concept from the source set
type ConceptMapGroupElement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Identifies element being mapped
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// Concept in target system for element
	Target []ConceptMapGroupElementTarget `json:"target,omitempty"`
}

// ConceptMapGroupElementTarget represents the ConceptMap.group.element.target backbone element.
// Concept in target system for element
type ConceptMapGroupElementTarget struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Code that identifies the target element
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// relatedto | equivalent | equal | wider | subsumes | narrower | specializes | inexact | unmatched | disjoint
	Equivalence *ConceptMapEquivalence `json:"equivalence,omitempty"`
	// Description of status/issues in mapping
	Comment *string `json:"comment,omitempty"`
	// Other elements required for this mapping (from context)
	DependsOn []ConceptMapGroupElementTargetDependsOn `json:"dependsOn,omitempty"`
	// Other concepts that this mapping also produces
	Product []ConceptMapGroupElementTargetDependsOn `json:"product,omitempty"`
}

// ConceptMapGroupElementTargetDependsOn represents the ConceptMap.group.element.target.dependsOn backbone element.
// Other elements required for this mapping (from context)
type ConceptMapGroupElementTargetDependsOn struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Reference to property mapping depends on
	Property *string `json:"property,omitempty"`
	// Code System (if necessary)
	System *string `json:"system,omitempty"`
	// Value of the referenced element
	Value *string `json:"value,omitempty"`
	// Display for the code (if value is a code)
	Display *string `json:"display,omitempty"`
}

// ConceptMapGroupUnmapped represents the ConceptMap.group.unmapped backbone element.
// What to do when there is no mapping for the source concept
type ConceptMapGroupUnmapped struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// provided | fixed | other-map
	Mode *ConceptMapGroupUnmappedMode `json:"mode,omitempty"`
	// Fixed code when mode = fixed
	Code *string `json:"code,omitempty"`
	// Display for the code
	Display *string `json:"display,omitempty"`
	// canonical reference to an additional ConceptMap to use for mapping if the source concept is unmapped
	Url *string `json:"url,omitempty"`
}
