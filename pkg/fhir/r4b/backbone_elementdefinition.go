// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (backbone elements)
// Package: r4b

package r4b

// ElementDefinitionBase represents the ElementDefinition.base backbone element.
// Base definition information for tools
type ElementDefinitionBase struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Path that identifies the base element
	Path *string `json:"path,omitempty"`
	// Min cardinality of the base element
	Min *uint32 `json:"min,omitempty"`
	// Max cardinality of the base element
	Max *string `json:"max,omitempty"`
}

// ElementDefinitionBinding represents the ElementDefinition.binding backbone element.
// ValueSet details if this is coded
type ElementDefinitionBinding struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// required | extensible | preferred | example
	Strength *BindingStrength `json:"strength,omitempty"`
	// Human explanation of the value set
	Description *string `json:"description,omitempty"`
	// Source of value set
	ValueSet *string `json:"valueSet,omitempty"`
}

// ElementDefinitionConstraint represents the ElementDefinition.constraint backbone element.
// Condition that must evaluate to true
type ElementDefinitionConstraint struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Target of 'condition' reference above
	Key *string `json:"key,omitempty"`
	// Why this constraint is necessary or appropriate
	Requirements *string `json:"requirements,omitempty"`
	// error | warning
	Severity *ConstraintSeverity `json:"severity,omitempty"`
	// Human description of constraint
	Human *string `json:"human,omitempty"`
	// FHIRPath expression of constraint
	Expression *string `json:"expression,omitempty"`
	// XPath expression of constraint
	Xpath *string `json:"xpath,omitempty"`
	// Reference to original source of constraint
	Source *string `json:"source,omitempty"`
}

// ElementDefinitionExample represents the ElementDefinition.example backbone element.
// Example value (as defined for type)
type ElementDefinitionExample struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Describes the purpose of this example
	Label *string `json:"label,omitempty"`
	// Value of Example (one of allowed types)
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// Value of Example (one of allowed types)
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of Example (one of allowed types)
	ValueCanonical *string `json:"valueCanonical,omitempty"`
	// Extension for ValueCanonical
	ValueCanonicalExt *Element `json:"_valueCanonical,omitempty"`
	// Value of Example (one of allowed types)
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// Value of Example (one of allowed types)
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Value of Example (one of allowed types)
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Value of Example (one of allowed types)
	ValueDecimal *float64 `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Value of Example (one of allowed types)
	ValueId *string `json:"valueId,omitempty"`
	// Extension for ValueId
	ValueIdExt *Element `json:"_valueId,omitempty"`
	// Value of Example (one of allowed types)
	ValueInstant *string `json:"valueInstant,omitempty"`
	// Extension for ValueInstant
	ValueInstantExt *Element `json:"_valueInstant,omitempty"`
	// Value of Example (one of allowed types)
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of Example (one of allowed types)
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// Value of Example (one of allowed types)
	ValueOid *string `json:"valueOid,omitempty"`
	// Extension for ValueOid
	ValueOidExt *Element `json:"_valueOid,omitempty"`
	// Value of Example (one of allowed types)
	ValuePositiveInt *uint32 `json:"valuePositiveInt,omitempty"`
	// Extension for ValuePositiveInt
	ValuePositiveIntExt *Element `json:"_valuePositiveInt,omitempty"`
	// Value of Example (one of allowed types)
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of Example (one of allowed types)
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Value of Example (one of allowed types)
	ValueUnsignedInt *uint32 `json:"valueUnsignedInt,omitempty"`
	// Extension for ValueUnsignedInt
	ValueUnsignedIntExt *Element `json:"_valueUnsignedInt,omitempty"`
	// Value of Example (one of allowed types)
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// Value of Example (one of allowed types)
	ValueUrl *string `json:"valueUrl,omitempty"`
	// Extension for ValueUrl
	ValueUrlExt *Element `json:"_valueUrl,omitempty"`
	// Value of Example (one of allowed types)
	ValueUuid *string `json:"valueUuid,omitempty"`
	// Extension for ValueUuid
	ValueUuidExt *Element `json:"_valueUuid,omitempty"`
	// Value of Example (one of allowed types)
	ValueAddress *Address `json:"valueAddress,omitempty"`
	// Value of Example (one of allowed types)
	ValueAge *Age `json:"valueAge,omitempty"`
	// Value of Example (one of allowed types)
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`
	// Value of Example (one of allowed types)
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// Value of Example (one of allowed types)
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value of Example (one of allowed types)
	ValueCodeableReference *CodeableReference `json:"valueCodeableReference,omitempty"`
	// Value of Example (one of allowed types)
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of Example (one of allowed types)
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`
	// Value of Example (one of allowed types)
	ValueCount *Count `json:"valueCount,omitempty"`
	// Value of Example (one of allowed types)
	ValueDistance *Distance `json:"valueDistance,omitempty"`
	// Value of Example (one of allowed types)
	ValueDuration *Duration `json:"valueDuration,omitempty"`
	// Value of Example (one of allowed types)
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`
	// Value of Example (one of allowed types)
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`
	// Value of Example (one of allowed types)
	ValueMoney *Money `json:"valueMoney,omitempty"`
	// Value of Example (one of allowed types)
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// Value of Example (one of allowed types)
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of Example (one of allowed types)
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of Example (one of allowed types)
	ValueRatio *Ratio `json:"valueRatio,omitempty"`
	// Value of Example (one of allowed types)
	ValueRatioRange *RatioRange `json:"valueRatioRange,omitempty"`
	// Value of Example (one of allowed types)
	ValueReference *Reference `json:"valueReference,omitempty"`
	// Value of Example (one of allowed types)
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`
	// Value of Example (one of allowed types)
	ValueSignature *Signature `json:"valueSignature,omitempty"`
	// Value of Example (one of allowed types)
	ValueTiming *Timing `json:"valueTiming,omitempty"`
	// Value of Example (one of allowed types)
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`
	// Value of Example (one of allowed types)
	ValueContributor *Contributor `json:"valueContributor,omitempty"`
	// Value of Example (one of allowed types)
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`
	// Value of Example (one of allowed types)
	ValueExpression *Expression `json:"valueExpression,omitempty"`
	// Value of Example (one of allowed types)
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// Value of Example (one of allowed types)
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// Value of Example (one of allowed types)
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// Value of Example (one of allowed types)
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`
	// Value of Example (one of allowed types)
	ValueDosage *Dosage `json:"valueDosage,omitempty"`
}

// ElementDefinitionMapping represents the ElementDefinition.mapping backbone element.
// Map element to another set of definitions
type ElementDefinitionMapping struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Reference to mapping declaration
	Identity *string `json:"identity,omitempty"`
	// Computable language of mapping
	Language *string `json:"language,omitempty"`
	// Details of the mapping
	Map *string `json:"map,omitempty"`
	// Comments about the mapping or its use
	Comment *string `json:"comment,omitempty"`
}

// ElementDefinitionSlicing represents the ElementDefinition.slicing backbone element.
// This element is sliced - slices follow
type ElementDefinitionSlicing struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Element values that are used to distinguish the slices
	Discriminator []ElementDefinitionSlicingDiscriminator `json:"discriminator,omitempty"`
	// Text description of how slicing works (or not)
	Description *string `json:"description,omitempty"`
	// If elements must be in same order as slices
	Ordered *bool `json:"ordered,omitempty"`
	// closed | open | openAtEnd
	Rules *SlicingRules `json:"rules,omitempty"`
}

// ElementDefinitionSlicingDiscriminator represents the ElementDefinition.slicing.discriminator backbone element.
// Element values that are used to distinguish the slices
type ElementDefinitionSlicingDiscriminator struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// value | exists | pattern | type | profile
	Type *DiscriminatorType `json:"type,omitempty"`
	// Path to element value
	Path *string `json:"path,omitempty"`
}

// ElementDefinitionType represents the ElementDefinition.type backbone element.
// Data type and Profile for this element
type ElementDefinitionType struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Data type or Resource (reference to definition)
	Code *string `json:"code,omitempty"`
	// Profiles (StructureDefinition or IG) - one must apply
	Profile []string `json:"profile,omitempty"`
	// Profile (StructureDefinition or IG) on the Reference/canonical target - one must apply
	TargetProfile []string `json:"targetProfile,omitempty"`
	// contained | referenced | bundled - how aggregated
	Aggregation []AggregationMode `json:"aggregation,omitempty"`
	// either | independent | specific
	Versioning *ReferenceVersionRules `json:"versioning,omitempty"`
}
