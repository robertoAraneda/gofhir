// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (backbone elements)
// Package: r4b

package r4b

import (
	"encoding/json"
	"fmt"
)

// ParametersParameter represents the Parameters.parameter backbone element.
// Operation Parameter
type ParametersParameter struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Name from the definition
	Name *string `json:"name,omitempty"`
	// If parameter is a data type
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// If parameter is a data type
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// If parameter is a data type
	ValueCanonical *string `json:"valueCanonical,omitempty"`
	// Extension for ValueCanonical
	ValueCanonicalExt *Element `json:"_valueCanonical,omitempty"`
	// If parameter is a data type
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// If parameter is a data type
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// If parameter is a data type
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// If parameter is a data type
	ValueDecimal *float64 `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// If parameter is a data type
	ValueId *string `json:"valueId,omitempty"`
	// Extension for ValueId
	ValueIdExt *Element `json:"_valueId,omitempty"`
	// If parameter is a data type
	ValueInstant *string `json:"valueInstant,omitempty"`
	// Extension for ValueInstant
	ValueInstantExt *Element `json:"_valueInstant,omitempty"`
	// If parameter is a data type
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// If parameter is a data type
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// If parameter is a data type
	ValueOid *string `json:"valueOid,omitempty"`
	// Extension for ValueOid
	ValueOidExt *Element `json:"_valueOid,omitempty"`
	// If parameter is a data type
	ValuePositiveInt *uint32 `json:"valuePositiveInt,omitempty"`
	// Extension for ValuePositiveInt
	ValuePositiveIntExt *Element `json:"_valuePositiveInt,omitempty"`
	// If parameter is a data type
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// If parameter is a data type
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// If parameter is a data type
	ValueUnsignedInt *uint32 `json:"valueUnsignedInt,omitempty"`
	// Extension for ValueUnsignedInt
	ValueUnsignedIntExt *Element `json:"_valueUnsignedInt,omitempty"`
	// If parameter is a data type
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// If parameter is a data type
	ValueUrl *string `json:"valueUrl,omitempty"`
	// Extension for ValueUrl
	ValueUrlExt *Element `json:"_valueUrl,omitempty"`
	// If parameter is a data type
	ValueUuid *string `json:"valueUuid,omitempty"`
	// Extension for ValueUuid
	ValueUuidExt *Element `json:"_valueUuid,omitempty"`
	// If parameter is a data type
	ValueAddress *Address `json:"valueAddress,omitempty"`
	// If parameter is a data type
	ValueAge *Age `json:"valueAge,omitempty"`
	// If parameter is a data type
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`
	// If parameter is a data type
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// If parameter is a data type
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// If parameter is a data type
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// If parameter is a data type
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`
	// If parameter is a data type
	ValueCount *Count `json:"valueCount,omitempty"`
	// If parameter is a data type
	ValueDistance *Distance `json:"valueDistance,omitempty"`
	// If parameter is a data type
	ValueDuration *Duration `json:"valueDuration,omitempty"`
	// If parameter is a data type
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`
	// If parameter is a data type
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`
	// If parameter is a data type
	ValueMoney *Money `json:"valueMoney,omitempty"`
	// If parameter is a data type
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// If parameter is a data type
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// If parameter is a data type
	ValueRange *Range `json:"valueRange,omitempty"`
	// If parameter is a data type
	ValueRatio *Ratio `json:"valueRatio,omitempty"`
	// If parameter is a data type
	ValueReference *Reference `json:"valueReference,omitempty"`
	// If parameter is a data type
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`
	// If parameter is a data type
	ValueSignature *Signature `json:"valueSignature,omitempty"`
	// If parameter is a data type
	ValueTiming *Timing `json:"valueTiming,omitempty"`
	// If parameter is a data type
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`
	// If parameter is a data type
	ValueContributor *Contributor `json:"valueContributor,omitempty"`
	// If parameter is a data type
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`
	// If parameter is a data type
	ValueExpression *Expression `json:"valueExpression,omitempty"`
	// If parameter is a data type
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// If parameter is a data type
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// If parameter is a data type
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// If parameter is a data type
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`
	// If parameter is a data type
	ValueDosage *Dosage `json:"valueDosage,omitempty"`
	// If parameter is a data type
	ValueMeta *Meta `json:"valueMeta,omitempty"`
	// If parameter is a whole resource
	Resource Resource `json:"resource,omitempty"`
	// Named part of a multi-part parameter
	Part []ParametersParameter `json:"part,omitempty"`
}

// UnmarshalJSON handles deserialization of polymorphic resource field.
func (b *ParametersParameter) UnmarshalJSON(data []byte) error {
	// Use an alias to avoid infinite recursion
	type Alias ParametersParameter
	aux := &struct {
		Resource json.RawMessage `json:"resource,omitempty"`
		*Alias
	}{
		Alias: (*Alias)(b),
	}

	if err := json.Unmarshal(data, aux); err != nil {
		return err
	}

	// Unmarshal the resource field using the dispatcher
	if len(aux.Resource) > 0 {
		resource, err := UnmarshalResource(aux.Resource)
		if err != nil {
			return fmt.Errorf("failed to unmarshal resource: %w", err)
		}
		b.Resource = resource
	}

	return nil
}
