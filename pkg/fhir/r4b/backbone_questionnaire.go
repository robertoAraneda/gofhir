// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (backbone elements)
// Package: r4b

package r4b

// QuestionnaireItem represents the Questionnaire.item backbone element.
// Questions and sections within the Questionnaire
type QuestionnaireItem struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique id for item in questionnaire
	LinkId *string `json:"linkId,omitempty"`
	// ElementDefinition - details for the item
	Definition *string `json:"definition,omitempty"`
	// Corresponding concept for this item in a terminology
	Code []Coding `json:"code,omitempty"`
	// E.g. "1(a)", "2.5.3"
	Prefix *string `json:"prefix,omitempty"`
	// Primary text for the item
	Text *string `json:"text,omitempty"`
	// group | display | boolean | decimal | integer | date | dateTime +
	Type *QuestionnaireItemType `json:"type,omitempty"`
	// Only allow data when
	EnableWhen []QuestionnaireItemEnableWhen `json:"enableWhen,omitempty"`
	// all | any
	EnableBehavior *EnableWhenBehavior `json:"enableBehavior,omitempty"`
	// Whether the item must be included in data results
	Required *bool `json:"required,omitempty"`
	// Whether the item may repeat
	Repeats *bool `json:"repeats,omitempty"`
	// Don't allow human editing
	ReadOnly *bool `json:"readOnly,omitempty"`
	// No more than this many characters
	MaxLength *int `json:"maxLength,omitempty"`
	// Valueset containing permitted answers
	AnswerValueSet *string `json:"answerValueSet,omitempty"`
	// Permitted answer
	AnswerOption []QuestionnaireItemAnswerOption `json:"answerOption,omitempty"`
	// Initial value(s) when item is first rendered
	Initial []QuestionnaireItemInitial `json:"initial,omitempty"`
	// Nested questionnaire items
	Item []QuestionnaireItem `json:"item,omitempty"`
}

// QuestionnaireItemAnswerOption represents the Questionnaire.item.answerOption backbone element.
// Permitted answer
type QuestionnaireItemAnswerOption struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Answer value
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Answer value
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Answer value
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Answer value
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Answer value
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Answer value
	ValueReference *Reference `json:"valueReference,omitempty"`
	// Whether option is selected by default
	InitialSelected *bool `json:"initialSelected,omitempty"`
}

// QuestionnaireItemEnableWhen represents the Questionnaire.item.enableWhen backbone element.
// Only allow data when
type QuestionnaireItemEnableWhen struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Question that determines whether item is enabled
	Question *string `json:"question,omitempty"`
	// exists | = | != | > | < | >= | <=
	Operator *QuestionnaireItemOperator `json:"operator,omitempty"`
	// Value for question comparison based on operator
	AnswerBoolean *bool `json:"answerBoolean,omitempty"`
	// Extension for AnswerBoolean
	AnswerBooleanExt *Element `json:"_answerBoolean,omitempty"`
	// Value for question comparison based on operator
	AnswerDecimal *float64 `json:"answerDecimal,omitempty"`
	// Extension for AnswerDecimal
	AnswerDecimalExt *Element `json:"_answerDecimal,omitempty"`
	// Value for question comparison based on operator
	AnswerInteger *int `json:"answerInteger,omitempty"`
	// Extension for AnswerInteger
	AnswerIntegerExt *Element `json:"_answerInteger,omitempty"`
	// Value for question comparison based on operator
	AnswerDate *string `json:"answerDate,omitempty"`
	// Extension for AnswerDate
	AnswerDateExt *Element `json:"_answerDate,omitempty"`
	// Value for question comparison based on operator
	AnswerDateTime *string `json:"answerDateTime,omitempty"`
	// Extension for AnswerDateTime
	AnswerDateTimeExt *Element `json:"_answerDateTime,omitempty"`
	// Value for question comparison based on operator
	AnswerTime *string `json:"answerTime,omitempty"`
	// Extension for AnswerTime
	AnswerTimeExt *Element `json:"_answerTime,omitempty"`
	// Value for question comparison based on operator
	AnswerString *string `json:"answerString,omitempty"`
	// Extension for AnswerString
	AnswerStringExt *Element `json:"_answerString,omitempty"`
	// Value for question comparison based on operator
	AnswerCoding *Coding `json:"answerCoding,omitempty"`
	// Value for question comparison based on operator
	AnswerQuantity *Quantity `json:"answerQuantity,omitempty"`
	// Value for question comparison based on operator
	AnswerReference *Reference `json:"answerReference,omitempty"`
}

// QuestionnaireItemInitial represents the Questionnaire.item.initial backbone element.
// Initial value(s) when item is first rendered
type QuestionnaireItemInitial struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Actual value for initializing the question
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Actual value for initializing the question
	ValueDecimal *float64 `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Actual value for initializing the question
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Actual value for initializing the question
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Actual value for initializing the question
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Actual value for initializing the question
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Actual value for initializing the question
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Actual value for initializing the question
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// Actual value for initializing the question
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// Actual value for initializing the question
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Actual value for initializing the question
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Actual value for initializing the question
	ValueReference *Reference `json:"valueReference,omitempty"`
}
