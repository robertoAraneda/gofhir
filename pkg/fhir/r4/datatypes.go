// Code generated by gofhir. DO NOT EDIT.
// Source: FHIR StructureDefinitions (datatypes)
// Package: r4

package r4

// Address represents FHIR Address.
type Address struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// home | work | temp | old | billing - purpose of this address
	Use *string `json:"use,omitempty"`
	// postal | physical | both
	Type *string `json:"type,omitempty"`
	// Text representation of the address
	Text *string `json:"text,omitempty"`
	// Street name, number, direction & P.O. Box etc.
	Line []string `json:"line,omitempty"`
	// Name of city, town etc.
	City *string `json:"city,omitempty"`
	// District name (aka county)
	District *string `json:"district,omitempty"`
	// Sub-unit of country (abbreviations ok)
	State *string `json:"state,omitempty"`
	// Postal code for area
	PostalCode *string `json:"postalCode,omitempty"`
	// Country (e.g. can be ISO 3166 2 or 3 letter code)
	Country *string `json:"country,omitempty"`
	// Time period when address was/is in use
	Period *Period `json:"period,omitempty"`
}

// Age represents FHIR Age.
type Age struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// Annotation represents FHIR Annotation.
type Annotation struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Individual responsible for the annotation
	AuthorReference *Reference `json:"authorReference,omitempty"`
	// Individual responsible for the annotation
	AuthorString *string `json:"authorString,omitempty"`
	// Extension for AuthorString
	AuthorStringExt *Element `json:"_authorString,omitempty"`
	// When the annotation was made
	Time *string `json:"time,omitempty"`
	// The annotation  - text content (as markdown)
	Text *string `json:"text,omitempty"`
}

// Attachment represents FHIR Attachment.
type Attachment struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Mime type of the content, with charset etc.
	ContentType *string `json:"contentType,omitempty"`
	// Human language of the content (BCP-47)
	Language *string `json:"language,omitempty"`
	// Data inline, base64ed
	Data *string `json:"data,omitempty"`
	// Uri where the data can be found
	Url *string `json:"url,omitempty"`
	// Number of bytes of content (if url provided)
	Size *uint32 `json:"size,omitempty"`
	// Hash of the data (sha-1, base64ed)
	Hash *string `json:"hash,omitempty"`
	// Label to display in place of the data
	Title *string `json:"title,omitempty"`
	// Date attachment was first created
	Creation *string `json:"creation,omitempty"`
}

// BackboneElement represents FHIR BackboneElement.
type BackboneElement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
}

// CodeableConcept represents FHIR CodeableConcept.
type CodeableConcept struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Code defined by a terminology system
	Coding []Coding `json:"coding,omitempty"`
	// Plain text representation of the concept
	Text *string `json:"text,omitempty"`
}

// Coding represents FHIR Coding.
type Coding struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Identity of the terminology system
	System *string `json:"system,omitempty"`
	// Version of the system - if relevant
	Version *string `json:"version,omitempty"`
	// Symbol in syntax defined by the system
	Code *string `json:"code,omitempty"`
	// Representation defined by the system
	Display *string `json:"display,omitempty"`
	// If this coding was chosen directly by the user
	UserSelected *bool `json:"userSelected,omitempty"`
}

// ContactDetail represents FHIR ContactDetail.
type ContactDetail struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Name of an individual to contact
	Name *string `json:"name,omitempty"`
	// Contact details for individual or organization
	Telecom []ContactPoint `json:"telecom,omitempty"`
}

// ContactPoint represents FHIR ContactPoint.
type ContactPoint struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// phone | fax | email | pager | url | sms | other
	System *string `json:"system,omitempty"`
	// The actual contact point details
	Value *string `json:"value,omitempty"`
	// home | work | temp | old | mobile - purpose of this contact point
	Use *string `json:"use,omitempty"`
	// Specify preferred order of use (1 = highest)
	Rank *uint32 `json:"rank,omitempty"`
	// Time period when the contact point was/is in use
	Period *Period `json:"period,omitempty"`
}

// Contributor represents FHIR Contributor.
type Contributor struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// author | editor | reviewer | endorser
	Type *string `json:"type,omitempty"`
	// Who contributed the content
	Name *string `json:"name,omitempty"`
	// Contact details of the contributor
	Contact []ContactDetail `json:"contact,omitempty"`
}

// Count represents FHIR Count.
type Count struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// DataRequirement represents FHIR DataRequirement.
type DataRequirement struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// The type of the required data
	Type *string `json:"type,omitempty"`
	// The profile of the required data
	Profile []string `json:"profile,omitempty"`
	// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
	SubjectCodeableConcept *CodeableConcept `json:"subjectCodeableConcept,omitempty"`
	// E.g. Patient, Practitioner, RelatedPerson, Organization, Location, Device
	SubjectReference *Reference `json:"subjectReference,omitempty"`
	// Indicates specific structure elements that are referenced by the knowledge module
	MustSupport []string `json:"mustSupport,omitempty"`
	// What codes are expected
	CodeFilter []Element `json:"codeFilter,omitempty"`
	// What dates/date ranges are expected
	DateFilter []Element `json:"dateFilter,omitempty"`
	// Number of results
	Limit *uint32 `json:"limit,omitempty"`
	// Order of the results
	Sort []Element `json:"sort,omitempty"`
}

// Distance represents FHIR Distance.
type Distance struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// Dosage represents FHIR Dosage.
type Dosage struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The order of the dosage instructions
	Sequence *int `json:"sequence,omitempty"`
	// Free text dosage instructions e.g. SIG
	Text *string `json:"text,omitempty"`
	// Supplemental instruction or warnings to the patient - e.g. "with meals", "may cause drowsiness"
	AdditionalInstruction []CodeableConcept `json:"additionalInstruction,omitempty"`
	// Patient or consumer oriented instructions
	PatientInstruction *string `json:"patientInstruction,omitempty"`
	// When medication should be administered
	Timing *Timing `json:"timing,omitempty"`
	// Take "as needed" (for x)
	AsNeededBoolean *bool `json:"asNeededBoolean,omitempty"`
	// Extension for AsNeededBoolean
	AsNeededBooleanExt *Element `json:"_asNeededBoolean,omitempty"`
	// Take "as needed" (for x)
	AsNeededCodeableConcept *CodeableConcept `json:"asNeededCodeableConcept,omitempty"`
	// Body site to administer to
	Site *CodeableConcept `json:"site,omitempty"`
	// How drug should enter body
	Route *CodeableConcept `json:"route,omitempty"`
	// Technique for administering medication
	Method *CodeableConcept `json:"method,omitempty"`
	// Amount of medication administered
	DoseAndRate []Element `json:"doseAndRate,omitempty"`
	// Upper limit on medication per unit of time
	MaxDosePerPeriod *Ratio `json:"maxDosePerPeriod,omitempty"`
	// Upper limit on medication per administration
	MaxDosePerAdministration *Quantity `json:"maxDosePerAdministration,omitempty"`
	// Upper limit on medication per lifetime of the patient
	MaxDosePerLifetime *Quantity `json:"maxDosePerLifetime,omitempty"`
}

// Duration represents FHIR Duration.
type Duration struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// Element represents FHIR Element.
type Element struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
}

// ElementDefinition represents FHIR ElementDefinition.
type ElementDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Path of the element in the hierarchy of elements
	Path *string `json:"path,omitempty"`
	// xmlAttr | xmlText | typeAttr | cdaText | xhtml
	Representation []string `json:"representation,omitempty"`
	// Name for this particular element (in a set of slices)
	SliceName *string `json:"sliceName,omitempty"`
	// If this slice definition constrains an inherited slice definition (or not)
	SliceIsConstraining *bool `json:"sliceIsConstraining,omitempty"`
	// Name for element to display with or prompt for element
	Label *string `json:"label,omitempty"`
	// Corresponding codes in terminologies
	Code []Coding `json:"code,omitempty"`
	// This element is sliced - slices follow
	Slicing *Element `json:"slicing,omitempty"`
	// Concise definition for space-constrained presentation
	Short *string `json:"short,omitempty"`
	// Full formal definition as narrative text
	Definition *string `json:"definition,omitempty"`
	// Comments about the use of this element
	Comment *string `json:"comment,omitempty"`
	// Why this resource has been created
	Requirements *string `json:"requirements,omitempty"`
	// Other names
	Alias []string `json:"alias,omitempty"`
	// Minimum Cardinality
	Min *uint32 `json:"min,omitempty"`
	// Maximum Cardinality (a number or *)
	Max *string `json:"max,omitempty"`
	// Base definition information for tools
	Base *Element `json:"base,omitempty"`
	// Reference to definition of content for the element
	ContentReference *string `json:"contentReference,omitempty"`
	// Data type and Profile for this element
	Type []Element `json:"type,omitempty"`
	// Specified value if missing from instance
	DefaultValueBase64Binary *string `json:"defaultValueBase64Binary,omitempty"`
	// Extension for DefaultValueBase64Binary
	DefaultValueBase64BinaryExt *Element `json:"_defaultValueBase64Binary,omitempty"`
	// Specified value if missing from instance
	DefaultValueBoolean *bool `json:"defaultValueBoolean,omitempty"`
	// Extension for DefaultValueBoolean
	DefaultValueBooleanExt *Element `json:"_defaultValueBoolean,omitempty"`
	// Specified value if missing from instance
	DefaultValueCanonical *string `json:"defaultValueCanonical,omitempty"`
	// Extension for DefaultValueCanonical
	DefaultValueCanonicalExt *Element `json:"_defaultValueCanonical,omitempty"`
	// Specified value if missing from instance
	DefaultValueCode *string `json:"defaultValueCode,omitempty"`
	// Extension for DefaultValueCode
	DefaultValueCodeExt *Element `json:"_defaultValueCode,omitempty"`
	// Specified value if missing from instance
	DefaultValueDate *string `json:"defaultValueDate,omitempty"`
	// Extension for DefaultValueDate
	DefaultValueDateExt *Element `json:"_defaultValueDate,omitempty"`
	// Specified value if missing from instance
	DefaultValueDateTime *string `json:"defaultValueDateTime,omitempty"`
	// Extension for DefaultValueDateTime
	DefaultValueDateTimeExt *Element `json:"_defaultValueDateTime,omitempty"`
	// Specified value if missing from instance
	DefaultValueDecimal *float64 `json:"defaultValueDecimal,omitempty"`
	// Extension for DefaultValueDecimal
	DefaultValueDecimalExt *Element `json:"_defaultValueDecimal,omitempty"`
	// Specified value if missing from instance
	DefaultValueId *string `json:"defaultValueId,omitempty"`
	// Extension for DefaultValueId
	DefaultValueIdExt *Element `json:"_defaultValueId,omitempty"`
	// Specified value if missing from instance
	DefaultValueInstant *string `json:"defaultValueInstant,omitempty"`
	// Extension for DefaultValueInstant
	DefaultValueInstantExt *Element `json:"_defaultValueInstant,omitempty"`
	// Specified value if missing from instance
	DefaultValueInteger *int `json:"defaultValueInteger,omitempty"`
	// Extension for DefaultValueInteger
	DefaultValueIntegerExt *Element `json:"_defaultValueInteger,omitempty"`
	// Specified value if missing from instance
	DefaultValueMarkdown *string `json:"defaultValueMarkdown,omitempty"`
	// Extension for DefaultValueMarkdown
	DefaultValueMarkdownExt *Element `json:"_defaultValueMarkdown,omitempty"`
	// Specified value if missing from instance
	DefaultValueOid *string `json:"defaultValueOid,omitempty"`
	// Extension for DefaultValueOid
	DefaultValueOidExt *Element `json:"_defaultValueOid,omitempty"`
	// Specified value if missing from instance
	DefaultValuePositiveInt *uint32 `json:"defaultValuePositiveInt,omitempty"`
	// Extension for DefaultValuePositiveInt
	DefaultValuePositiveIntExt *Element `json:"_defaultValuePositiveInt,omitempty"`
	// Specified value if missing from instance
	DefaultValueString *string `json:"defaultValueString,omitempty"`
	// Extension for DefaultValueString
	DefaultValueStringExt *Element `json:"_defaultValueString,omitempty"`
	// Specified value if missing from instance
	DefaultValueTime *string `json:"defaultValueTime,omitempty"`
	// Extension for DefaultValueTime
	DefaultValueTimeExt *Element `json:"_defaultValueTime,omitempty"`
	// Specified value if missing from instance
	DefaultValueUnsignedInt *uint32 `json:"defaultValueUnsignedInt,omitempty"`
	// Extension for DefaultValueUnsignedInt
	DefaultValueUnsignedIntExt *Element `json:"_defaultValueUnsignedInt,omitempty"`
	// Specified value if missing from instance
	DefaultValueUri *string `json:"defaultValueUri,omitempty"`
	// Extension for DefaultValueUri
	DefaultValueUriExt *Element `json:"_defaultValueUri,omitempty"`
	// Specified value if missing from instance
	DefaultValueUrl *string `json:"defaultValueUrl,omitempty"`
	// Extension for DefaultValueUrl
	DefaultValueUrlExt *Element `json:"_defaultValueUrl,omitempty"`
	// Specified value if missing from instance
	DefaultValueUuid *string `json:"defaultValueUuid,omitempty"`
	// Extension for DefaultValueUuid
	DefaultValueUuidExt *Element `json:"_defaultValueUuid,omitempty"`
	// Specified value if missing from instance
	DefaultValueAddress *Address `json:"defaultValueAddress,omitempty"`
	// Specified value if missing from instance
	DefaultValueAge *Age `json:"defaultValueAge,omitempty"`
	// Specified value if missing from instance
	DefaultValueAnnotation *Annotation `json:"defaultValueAnnotation,omitempty"`
	// Specified value if missing from instance
	DefaultValueAttachment *Attachment `json:"defaultValueAttachment,omitempty"`
	// Specified value if missing from instance
	DefaultValueCodeableConcept *CodeableConcept `json:"defaultValueCodeableConcept,omitempty"`
	// Specified value if missing from instance
	DefaultValueCoding *Coding `json:"defaultValueCoding,omitempty"`
	// Specified value if missing from instance
	DefaultValueContactPoint *ContactPoint `json:"defaultValueContactPoint,omitempty"`
	// Specified value if missing from instance
	DefaultValueCount *Count `json:"defaultValueCount,omitempty"`
	// Specified value if missing from instance
	DefaultValueDistance *Distance `json:"defaultValueDistance,omitempty"`
	// Specified value if missing from instance
	DefaultValueDuration *Duration `json:"defaultValueDuration,omitempty"`
	// Specified value if missing from instance
	DefaultValueHumanName *HumanName `json:"defaultValueHumanName,omitempty"`
	// Specified value if missing from instance
	DefaultValueIdentifier *Identifier `json:"defaultValueIdentifier,omitempty"`
	// Specified value if missing from instance
	DefaultValueMoney *Money `json:"defaultValueMoney,omitempty"`
	// Specified value if missing from instance
	DefaultValuePeriod *Period `json:"defaultValuePeriod,omitempty"`
	// Specified value if missing from instance
	DefaultValueQuantity *Quantity `json:"defaultValueQuantity,omitempty"`
	// Specified value if missing from instance
	DefaultValueRange *Range `json:"defaultValueRange,omitempty"`
	// Specified value if missing from instance
	DefaultValueRatio *Ratio `json:"defaultValueRatio,omitempty"`
	// Specified value if missing from instance
	DefaultValueReference *Reference `json:"defaultValueReference,omitempty"`
	// Specified value if missing from instance
	DefaultValueSampledData *SampledData `json:"defaultValueSampledData,omitempty"`
	// Specified value if missing from instance
	DefaultValueSignature *Signature `json:"defaultValueSignature,omitempty"`
	// Specified value if missing from instance
	DefaultValueTiming *Timing `json:"defaultValueTiming,omitempty"`
	// Specified value if missing from instance
	DefaultValueContactDetail *ContactDetail `json:"defaultValueContactDetail,omitempty"`
	// Specified value if missing from instance
	DefaultValueContributor *Contributor `json:"defaultValueContributor,omitempty"`
	// Specified value if missing from instance
	DefaultValueDataRequirement *DataRequirement `json:"defaultValueDataRequirement,omitempty"`
	// Specified value if missing from instance
	DefaultValueExpression *Expression `json:"defaultValueExpression,omitempty"`
	// Specified value if missing from instance
	DefaultValueParameterDefinition *ParameterDefinition `json:"defaultValueParameterDefinition,omitempty"`
	// Specified value if missing from instance
	DefaultValueRelatedArtifact *RelatedArtifact `json:"defaultValueRelatedArtifact,omitempty"`
	// Specified value if missing from instance
	DefaultValueTriggerDefinition *TriggerDefinition `json:"defaultValueTriggerDefinition,omitempty"`
	// Specified value if missing from instance
	DefaultValueUsageContext *UsageContext `json:"defaultValueUsageContext,omitempty"`
	// Specified value if missing from instance
	DefaultValueDosage *Dosage `json:"defaultValueDosage,omitempty"`
	// Specified value if missing from instance
	DefaultValueMeta *Meta `json:"defaultValueMeta,omitempty"`
	// Implicit meaning when this element is missing
	MeaningWhenMissing *string `json:"meaningWhenMissing,omitempty"`
	// What the order of the elements means
	OrderMeaning *string `json:"orderMeaning,omitempty"`
	// Value must be exactly this
	FixedBase64Binary *string `json:"fixedBase64Binary,omitempty"`
	// Extension for FixedBase64Binary
	FixedBase64BinaryExt *Element `json:"_fixedBase64Binary,omitempty"`
	// Value must be exactly this
	FixedBoolean *bool `json:"fixedBoolean,omitempty"`
	// Extension for FixedBoolean
	FixedBooleanExt *Element `json:"_fixedBoolean,omitempty"`
	// Value must be exactly this
	FixedCanonical *string `json:"fixedCanonical,omitempty"`
	// Extension for FixedCanonical
	FixedCanonicalExt *Element `json:"_fixedCanonical,omitempty"`
	// Value must be exactly this
	FixedCode *string `json:"fixedCode,omitempty"`
	// Extension for FixedCode
	FixedCodeExt *Element `json:"_fixedCode,omitempty"`
	// Value must be exactly this
	FixedDate *string `json:"fixedDate,omitempty"`
	// Extension for FixedDate
	FixedDateExt *Element `json:"_fixedDate,omitempty"`
	// Value must be exactly this
	FixedDateTime *string `json:"fixedDateTime,omitempty"`
	// Extension for FixedDateTime
	FixedDateTimeExt *Element `json:"_fixedDateTime,omitempty"`
	// Value must be exactly this
	FixedDecimal *float64 `json:"fixedDecimal,omitempty"`
	// Extension for FixedDecimal
	FixedDecimalExt *Element `json:"_fixedDecimal,omitempty"`
	// Value must be exactly this
	FixedId *string `json:"fixedId,omitempty"`
	// Extension for FixedId
	FixedIdExt *Element `json:"_fixedId,omitempty"`
	// Value must be exactly this
	FixedInstant *string `json:"fixedInstant,omitempty"`
	// Extension for FixedInstant
	FixedInstantExt *Element `json:"_fixedInstant,omitempty"`
	// Value must be exactly this
	FixedInteger *int `json:"fixedInteger,omitempty"`
	// Extension for FixedInteger
	FixedIntegerExt *Element `json:"_fixedInteger,omitempty"`
	// Value must be exactly this
	FixedMarkdown *string `json:"fixedMarkdown,omitempty"`
	// Extension for FixedMarkdown
	FixedMarkdownExt *Element `json:"_fixedMarkdown,omitempty"`
	// Value must be exactly this
	FixedOid *string `json:"fixedOid,omitempty"`
	// Extension for FixedOid
	FixedOidExt *Element `json:"_fixedOid,omitempty"`
	// Value must be exactly this
	FixedPositiveInt *uint32 `json:"fixedPositiveInt,omitempty"`
	// Extension for FixedPositiveInt
	FixedPositiveIntExt *Element `json:"_fixedPositiveInt,omitempty"`
	// Value must be exactly this
	FixedString *string `json:"fixedString,omitempty"`
	// Extension for FixedString
	FixedStringExt *Element `json:"_fixedString,omitempty"`
	// Value must be exactly this
	FixedTime *string `json:"fixedTime,omitempty"`
	// Extension for FixedTime
	FixedTimeExt *Element `json:"_fixedTime,omitempty"`
	// Value must be exactly this
	FixedUnsignedInt *uint32 `json:"fixedUnsignedInt,omitempty"`
	// Extension for FixedUnsignedInt
	FixedUnsignedIntExt *Element `json:"_fixedUnsignedInt,omitempty"`
	// Value must be exactly this
	FixedUri *string `json:"fixedUri,omitempty"`
	// Extension for FixedUri
	FixedUriExt *Element `json:"_fixedUri,omitempty"`
	// Value must be exactly this
	FixedUrl *string `json:"fixedUrl,omitempty"`
	// Extension for FixedUrl
	FixedUrlExt *Element `json:"_fixedUrl,omitempty"`
	// Value must be exactly this
	FixedUuid *string `json:"fixedUuid,omitempty"`
	// Extension for FixedUuid
	FixedUuidExt *Element `json:"_fixedUuid,omitempty"`
	// Value must be exactly this
	FixedAddress *Address `json:"fixedAddress,omitempty"`
	// Value must be exactly this
	FixedAge *Age `json:"fixedAge,omitempty"`
	// Value must be exactly this
	FixedAnnotation *Annotation `json:"fixedAnnotation,omitempty"`
	// Value must be exactly this
	FixedAttachment *Attachment `json:"fixedAttachment,omitempty"`
	// Value must be exactly this
	FixedCodeableConcept *CodeableConcept `json:"fixedCodeableConcept,omitempty"`
	// Value must be exactly this
	FixedCoding *Coding `json:"fixedCoding,omitempty"`
	// Value must be exactly this
	FixedContactPoint *ContactPoint `json:"fixedContactPoint,omitempty"`
	// Value must be exactly this
	FixedCount *Count `json:"fixedCount,omitempty"`
	// Value must be exactly this
	FixedDistance *Distance `json:"fixedDistance,omitempty"`
	// Value must be exactly this
	FixedDuration *Duration `json:"fixedDuration,omitempty"`
	// Value must be exactly this
	FixedHumanName *HumanName `json:"fixedHumanName,omitempty"`
	// Value must be exactly this
	FixedIdentifier *Identifier `json:"fixedIdentifier,omitempty"`
	// Value must be exactly this
	FixedMoney *Money `json:"fixedMoney,omitempty"`
	// Value must be exactly this
	FixedPeriod *Period `json:"fixedPeriod,omitempty"`
	// Value must be exactly this
	FixedQuantity *Quantity `json:"fixedQuantity,omitempty"`
	// Value must be exactly this
	FixedRange *Range `json:"fixedRange,omitempty"`
	// Value must be exactly this
	FixedRatio *Ratio `json:"fixedRatio,omitempty"`
	// Value must be exactly this
	FixedReference *Reference `json:"fixedReference,omitempty"`
	// Value must be exactly this
	FixedSampledData *SampledData `json:"fixedSampledData,omitempty"`
	// Value must be exactly this
	FixedSignature *Signature `json:"fixedSignature,omitempty"`
	// Value must be exactly this
	FixedTiming *Timing `json:"fixedTiming,omitempty"`
	// Value must be exactly this
	FixedContactDetail *ContactDetail `json:"fixedContactDetail,omitempty"`
	// Value must be exactly this
	FixedContributor *Contributor `json:"fixedContributor,omitempty"`
	// Value must be exactly this
	FixedDataRequirement *DataRequirement `json:"fixedDataRequirement,omitempty"`
	// Value must be exactly this
	FixedExpression *Expression `json:"fixedExpression,omitempty"`
	// Value must be exactly this
	FixedParameterDefinition *ParameterDefinition `json:"fixedParameterDefinition,omitempty"`
	// Value must be exactly this
	FixedRelatedArtifact *RelatedArtifact `json:"fixedRelatedArtifact,omitempty"`
	// Value must be exactly this
	FixedTriggerDefinition *TriggerDefinition `json:"fixedTriggerDefinition,omitempty"`
	// Value must be exactly this
	FixedUsageContext *UsageContext `json:"fixedUsageContext,omitempty"`
	// Value must be exactly this
	FixedDosage *Dosage `json:"fixedDosage,omitempty"`
	// Value must be exactly this
	FixedMeta *Meta `json:"fixedMeta,omitempty"`
	// Value must have at least these property values
	PatternBase64Binary *string `json:"patternBase64Binary,omitempty"`
	// Extension for PatternBase64Binary
	PatternBase64BinaryExt *Element `json:"_patternBase64Binary,omitempty"`
	// Value must have at least these property values
	PatternBoolean *bool `json:"patternBoolean,omitempty"`
	// Extension for PatternBoolean
	PatternBooleanExt *Element `json:"_patternBoolean,omitempty"`
	// Value must have at least these property values
	PatternCanonical *string `json:"patternCanonical,omitempty"`
	// Extension for PatternCanonical
	PatternCanonicalExt *Element `json:"_patternCanonical,omitempty"`
	// Value must have at least these property values
	PatternCode *string `json:"patternCode,omitempty"`
	// Extension for PatternCode
	PatternCodeExt *Element `json:"_patternCode,omitempty"`
	// Value must have at least these property values
	PatternDate *string `json:"patternDate,omitempty"`
	// Extension for PatternDate
	PatternDateExt *Element `json:"_patternDate,omitempty"`
	// Value must have at least these property values
	PatternDateTime *string `json:"patternDateTime,omitempty"`
	// Extension for PatternDateTime
	PatternDateTimeExt *Element `json:"_patternDateTime,omitempty"`
	// Value must have at least these property values
	PatternDecimal *float64 `json:"patternDecimal,omitempty"`
	// Extension for PatternDecimal
	PatternDecimalExt *Element `json:"_patternDecimal,omitempty"`
	// Value must have at least these property values
	PatternId *string `json:"patternId,omitempty"`
	// Extension for PatternId
	PatternIdExt *Element `json:"_patternId,omitempty"`
	// Value must have at least these property values
	PatternInstant *string `json:"patternInstant,omitempty"`
	// Extension for PatternInstant
	PatternInstantExt *Element `json:"_patternInstant,omitempty"`
	// Value must have at least these property values
	PatternInteger *int `json:"patternInteger,omitempty"`
	// Extension for PatternInteger
	PatternIntegerExt *Element `json:"_patternInteger,omitempty"`
	// Value must have at least these property values
	PatternMarkdown *string `json:"patternMarkdown,omitempty"`
	// Extension for PatternMarkdown
	PatternMarkdownExt *Element `json:"_patternMarkdown,omitempty"`
	// Value must have at least these property values
	PatternOid *string `json:"patternOid,omitempty"`
	// Extension for PatternOid
	PatternOidExt *Element `json:"_patternOid,omitempty"`
	// Value must have at least these property values
	PatternPositiveInt *uint32 `json:"patternPositiveInt,omitempty"`
	// Extension for PatternPositiveInt
	PatternPositiveIntExt *Element `json:"_patternPositiveInt,omitempty"`
	// Value must have at least these property values
	PatternString *string `json:"patternString,omitempty"`
	// Extension for PatternString
	PatternStringExt *Element `json:"_patternString,omitempty"`
	// Value must have at least these property values
	PatternTime *string `json:"patternTime,omitempty"`
	// Extension for PatternTime
	PatternTimeExt *Element `json:"_patternTime,omitempty"`
	// Value must have at least these property values
	PatternUnsignedInt *uint32 `json:"patternUnsignedInt,omitempty"`
	// Extension for PatternUnsignedInt
	PatternUnsignedIntExt *Element `json:"_patternUnsignedInt,omitempty"`
	// Value must have at least these property values
	PatternUri *string `json:"patternUri,omitempty"`
	// Extension for PatternUri
	PatternUriExt *Element `json:"_patternUri,omitempty"`
	// Value must have at least these property values
	PatternUrl *string `json:"patternUrl,omitempty"`
	// Extension for PatternUrl
	PatternUrlExt *Element `json:"_patternUrl,omitempty"`
	// Value must have at least these property values
	PatternUuid *string `json:"patternUuid,omitempty"`
	// Extension for PatternUuid
	PatternUuidExt *Element `json:"_patternUuid,omitempty"`
	// Value must have at least these property values
	PatternAddress *Address `json:"patternAddress,omitempty"`
	// Value must have at least these property values
	PatternAge *Age `json:"patternAge,omitempty"`
	// Value must have at least these property values
	PatternAnnotation *Annotation `json:"patternAnnotation,omitempty"`
	// Value must have at least these property values
	PatternAttachment *Attachment `json:"patternAttachment,omitempty"`
	// Value must have at least these property values
	PatternCodeableConcept *CodeableConcept `json:"patternCodeableConcept,omitempty"`
	// Value must have at least these property values
	PatternCoding *Coding `json:"patternCoding,omitempty"`
	// Value must have at least these property values
	PatternContactPoint *ContactPoint `json:"patternContactPoint,omitempty"`
	// Value must have at least these property values
	PatternCount *Count `json:"patternCount,omitempty"`
	// Value must have at least these property values
	PatternDistance *Distance `json:"patternDistance,omitempty"`
	// Value must have at least these property values
	PatternDuration *Duration `json:"patternDuration,omitempty"`
	// Value must have at least these property values
	PatternHumanName *HumanName `json:"patternHumanName,omitempty"`
	// Value must have at least these property values
	PatternIdentifier *Identifier `json:"patternIdentifier,omitempty"`
	// Value must have at least these property values
	PatternMoney *Money `json:"patternMoney,omitempty"`
	// Value must have at least these property values
	PatternPeriod *Period `json:"patternPeriod,omitempty"`
	// Value must have at least these property values
	PatternQuantity *Quantity `json:"patternQuantity,omitempty"`
	// Value must have at least these property values
	PatternRange *Range `json:"patternRange,omitempty"`
	// Value must have at least these property values
	PatternRatio *Ratio `json:"patternRatio,omitempty"`
	// Value must have at least these property values
	PatternReference *Reference `json:"patternReference,omitempty"`
	// Value must have at least these property values
	PatternSampledData *SampledData `json:"patternSampledData,omitempty"`
	// Value must have at least these property values
	PatternSignature *Signature `json:"patternSignature,omitempty"`
	// Value must have at least these property values
	PatternTiming *Timing `json:"patternTiming,omitempty"`
	// Value must have at least these property values
	PatternContactDetail *ContactDetail `json:"patternContactDetail,omitempty"`
	// Value must have at least these property values
	PatternContributor *Contributor `json:"patternContributor,omitempty"`
	// Value must have at least these property values
	PatternDataRequirement *DataRequirement `json:"patternDataRequirement,omitempty"`
	// Value must have at least these property values
	PatternExpression *Expression `json:"patternExpression,omitempty"`
	// Value must have at least these property values
	PatternParameterDefinition *ParameterDefinition `json:"patternParameterDefinition,omitempty"`
	// Value must have at least these property values
	PatternRelatedArtifact *RelatedArtifact `json:"patternRelatedArtifact,omitempty"`
	// Value must have at least these property values
	PatternTriggerDefinition *TriggerDefinition `json:"patternTriggerDefinition,omitempty"`
	// Value must have at least these property values
	PatternUsageContext *UsageContext `json:"patternUsageContext,omitempty"`
	// Value must have at least these property values
	PatternDosage *Dosage `json:"patternDosage,omitempty"`
	// Value must have at least these property values
	PatternMeta *Meta `json:"patternMeta,omitempty"`
	// Example value (as defined for type)
	Example []Element `json:"example,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDate *string `json:"minValueDate,omitempty"`
	// Extension for MinValueDate
	MinValueDateExt *Element `json:"_minValueDate,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDateTime *string `json:"minValueDateTime,omitempty"`
	// Extension for MinValueDateTime
	MinValueDateTimeExt *Element `json:"_minValueDateTime,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueInstant *string `json:"minValueInstant,omitempty"`
	// Extension for MinValueInstant
	MinValueInstantExt *Element `json:"_minValueInstant,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueTime *string `json:"minValueTime,omitempty"`
	// Extension for MinValueTime
	MinValueTimeExt *Element `json:"_minValueTime,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueDecimal *float64 `json:"minValueDecimal,omitempty"`
	// Extension for MinValueDecimal
	MinValueDecimalExt *Element `json:"_minValueDecimal,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueInteger *int `json:"minValueInteger,omitempty"`
	// Extension for MinValueInteger
	MinValueIntegerExt *Element `json:"_minValueInteger,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValuePositiveInt *uint32 `json:"minValuePositiveInt,omitempty"`
	// Extension for MinValuePositiveInt
	MinValuePositiveIntExt *Element `json:"_minValuePositiveInt,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueUnsignedInt *uint32 `json:"minValueUnsignedInt,omitempty"`
	// Extension for MinValueUnsignedInt
	MinValueUnsignedIntExt *Element `json:"_minValueUnsignedInt,omitempty"`
	// Minimum Allowed Value (for some types)
	MinValueQuantity *Quantity `json:"minValueQuantity,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDate *string `json:"maxValueDate,omitempty"`
	// Extension for MaxValueDate
	MaxValueDateExt *Element `json:"_maxValueDate,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDateTime *string `json:"maxValueDateTime,omitempty"`
	// Extension for MaxValueDateTime
	MaxValueDateTimeExt *Element `json:"_maxValueDateTime,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueInstant *string `json:"maxValueInstant,omitempty"`
	// Extension for MaxValueInstant
	MaxValueInstantExt *Element `json:"_maxValueInstant,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueTime *string `json:"maxValueTime,omitempty"`
	// Extension for MaxValueTime
	MaxValueTimeExt *Element `json:"_maxValueTime,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueDecimal *float64 `json:"maxValueDecimal,omitempty"`
	// Extension for MaxValueDecimal
	MaxValueDecimalExt *Element `json:"_maxValueDecimal,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueInteger *int `json:"maxValueInteger,omitempty"`
	// Extension for MaxValueInteger
	MaxValueIntegerExt *Element `json:"_maxValueInteger,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValuePositiveInt *uint32 `json:"maxValuePositiveInt,omitempty"`
	// Extension for MaxValuePositiveInt
	MaxValuePositiveIntExt *Element `json:"_maxValuePositiveInt,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueUnsignedInt *uint32 `json:"maxValueUnsignedInt,omitempty"`
	// Extension for MaxValueUnsignedInt
	MaxValueUnsignedIntExt *Element `json:"_maxValueUnsignedInt,omitempty"`
	// Maximum Allowed Value (for some types)
	MaxValueQuantity *Quantity `json:"maxValueQuantity,omitempty"`
	// Max length for strings
	MaxLength *int `json:"maxLength,omitempty"`
	// Reference to invariant about presence
	Condition []string `json:"condition,omitempty"`
	// Condition that must evaluate to true
	Constraint []Element `json:"constraint,omitempty"`
	// If the element must be supported
	MustSupport *bool `json:"mustSupport,omitempty"`
	// If this modifies the meaning of other elements
	IsModifier *bool `json:"isModifier,omitempty"`
	// Reason that this element is marked as a modifier
	IsModifierReason *string `json:"isModifierReason,omitempty"`
	// Include when _summary = true?
	IsSummary *bool `json:"isSummary,omitempty"`
	// ValueSet details if this is coded
	Binding *Element `json:"binding,omitempty"`
	// Map element to another set of definitions
	Mapping []Element `json:"mapping,omitempty"`
}

// Expression represents FHIR Expression.
type Expression struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Natural language description of the condition
	Description *string `json:"description,omitempty"`
	// Short name assigned to expression for reuse
	Name *string `json:"name,omitempty"`
	// text/cql | text/fhirpath | application/x-fhir-query | etc.
	Language *string `json:"language,omitempty"`
	// Expression in specified language
	Expression *string `json:"expression,omitempty"`
	// Where the expression is found
	Reference *string `json:"reference,omitempty"`
}

// Extension represents FHIR Extension.
type Extension struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// identifies the meaning of the extension
	Url string `json:"url"`
	// Value of extension
	ValueBase64Binary *string `json:"valueBase64Binary,omitempty"`
	// Extension for ValueBase64Binary
	ValueBase64BinaryExt *Element `json:"_valueBase64Binary,omitempty"`
	// Value of extension
	ValueBoolean *bool `json:"valueBoolean,omitempty"`
	// Extension for ValueBoolean
	ValueBooleanExt *Element `json:"_valueBoolean,omitempty"`
	// Value of extension
	ValueCanonical *string `json:"valueCanonical,omitempty"`
	// Extension for ValueCanonical
	ValueCanonicalExt *Element `json:"_valueCanonical,omitempty"`
	// Value of extension
	ValueCode *string `json:"valueCode,omitempty"`
	// Extension for ValueCode
	ValueCodeExt *Element `json:"_valueCode,omitempty"`
	// Value of extension
	ValueDate *string `json:"valueDate,omitempty"`
	// Extension for ValueDate
	ValueDateExt *Element `json:"_valueDate,omitempty"`
	// Value of extension
	ValueDateTime *string `json:"valueDateTime,omitempty"`
	// Extension for ValueDateTime
	ValueDateTimeExt *Element `json:"_valueDateTime,omitempty"`
	// Value of extension
	ValueDecimal *float64 `json:"valueDecimal,omitempty"`
	// Extension for ValueDecimal
	ValueDecimalExt *Element `json:"_valueDecimal,omitempty"`
	// Value of extension
	ValueId *string `json:"valueId,omitempty"`
	// Extension for ValueId
	ValueIdExt *Element `json:"_valueId,omitempty"`
	// Value of extension
	ValueInstant *string `json:"valueInstant,omitempty"`
	// Extension for ValueInstant
	ValueInstantExt *Element `json:"_valueInstant,omitempty"`
	// Value of extension
	ValueInteger *int `json:"valueInteger,omitempty"`
	// Extension for ValueInteger
	ValueIntegerExt *Element `json:"_valueInteger,omitempty"`
	// Value of extension
	ValueMarkdown *string `json:"valueMarkdown,omitempty"`
	// Extension for ValueMarkdown
	ValueMarkdownExt *Element `json:"_valueMarkdown,omitempty"`
	// Value of extension
	ValueOid *string `json:"valueOid,omitempty"`
	// Extension for ValueOid
	ValueOidExt *Element `json:"_valueOid,omitempty"`
	// Value of extension
	ValuePositiveInt *uint32 `json:"valuePositiveInt,omitempty"`
	// Extension for ValuePositiveInt
	ValuePositiveIntExt *Element `json:"_valuePositiveInt,omitempty"`
	// Value of extension
	ValueString *string `json:"valueString,omitempty"`
	// Extension for ValueString
	ValueStringExt *Element `json:"_valueString,omitempty"`
	// Value of extension
	ValueTime *string `json:"valueTime,omitempty"`
	// Extension for ValueTime
	ValueTimeExt *Element `json:"_valueTime,omitempty"`
	// Value of extension
	ValueUnsignedInt *uint32 `json:"valueUnsignedInt,omitempty"`
	// Extension for ValueUnsignedInt
	ValueUnsignedIntExt *Element `json:"_valueUnsignedInt,omitempty"`
	// Value of extension
	ValueUri *string `json:"valueUri,omitempty"`
	// Extension for ValueUri
	ValueUriExt *Element `json:"_valueUri,omitempty"`
	// Value of extension
	ValueUrl *string `json:"valueUrl,omitempty"`
	// Extension for ValueUrl
	ValueUrlExt *Element `json:"_valueUrl,omitempty"`
	// Value of extension
	ValueUuid *string `json:"valueUuid,omitempty"`
	// Extension for ValueUuid
	ValueUuidExt *Element `json:"_valueUuid,omitempty"`
	// Value of extension
	ValueAddress *Address `json:"valueAddress,omitempty"`
	// Value of extension
	ValueAge *Age `json:"valueAge,omitempty"`
	// Value of extension
	ValueAnnotation *Annotation `json:"valueAnnotation,omitempty"`
	// Value of extension
	ValueAttachment *Attachment `json:"valueAttachment,omitempty"`
	// Value of extension
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value of extension
	ValueCoding *Coding `json:"valueCoding,omitempty"`
	// Value of extension
	ValueContactPoint *ContactPoint `json:"valueContactPoint,omitempty"`
	// Value of extension
	ValueCount *Count `json:"valueCount,omitempty"`
	// Value of extension
	ValueDistance *Distance `json:"valueDistance,omitempty"`
	// Value of extension
	ValueDuration *Duration `json:"valueDuration,omitempty"`
	// Value of extension
	ValueHumanName *HumanName `json:"valueHumanName,omitempty"`
	// Value of extension
	ValueIdentifier *Identifier `json:"valueIdentifier,omitempty"`
	// Value of extension
	ValueMoney *Money `json:"valueMoney,omitempty"`
	// Value of extension
	ValuePeriod *Period `json:"valuePeriod,omitempty"`
	// Value of extension
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value of extension
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value of extension
	ValueRatio *Ratio `json:"valueRatio,omitempty"`
	// Value of extension
	ValueReference *Reference `json:"valueReference,omitempty"`
	// Value of extension
	ValueSampledData *SampledData `json:"valueSampledData,omitempty"`
	// Value of extension
	ValueSignature *Signature `json:"valueSignature,omitempty"`
	// Value of extension
	ValueTiming *Timing `json:"valueTiming,omitempty"`
	// Value of extension
	ValueContactDetail *ContactDetail `json:"valueContactDetail,omitempty"`
	// Value of extension
	ValueContributor *Contributor `json:"valueContributor,omitempty"`
	// Value of extension
	ValueDataRequirement *DataRequirement `json:"valueDataRequirement,omitempty"`
	// Value of extension
	ValueExpression *Expression `json:"valueExpression,omitempty"`
	// Value of extension
	ValueParameterDefinition *ParameterDefinition `json:"valueParameterDefinition,omitempty"`
	// Value of extension
	ValueRelatedArtifact *RelatedArtifact `json:"valueRelatedArtifact,omitempty"`
	// Value of extension
	ValueTriggerDefinition *TriggerDefinition `json:"valueTriggerDefinition,omitempty"`
	// Value of extension
	ValueUsageContext *UsageContext `json:"valueUsageContext,omitempty"`
	// Value of extension
	ValueDosage *Dosage `json:"valueDosage,omitempty"`
	// Value of extension
	ValueMeta *Meta `json:"valueMeta,omitempty"`
}

// HumanName represents FHIR HumanName.
type HumanName struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// usual | official | temp | nickname | anonymous | old | maiden
	Use *string `json:"use,omitempty"`
	// Text representation of the full name
	Text *string `json:"text,omitempty"`
	// Family name (often called 'Surname')
	Family *string `json:"family,omitempty"`
	// Given names (not always 'first'). Includes middle names
	Given []string `json:"given,omitempty"`
	// Parts that come before the name
	Prefix []string `json:"prefix,omitempty"`
	// Parts that come after the name
	Suffix []string `json:"suffix,omitempty"`
	// Time period when name was/is in use
	Period *Period `json:"period,omitempty"`
}

// Identifier represents FHIR Identifier.
type Identifier struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// usual | official | temp | secondary | old (If known)
	Use *string `json:"use,omitempty"`
	// Description of identifier
	Type *CodeableConcept `json:"type,omitempty"`
	// The namespace for the identifier value
	System *string `json:"system,omitempty"`
	// The value that is unique
	Value *string `json:"value,omitempty"`
	// Time period when id is/was valid for use
	Period *Period `json:"period,omitempty"`
	// Organization that issued id (may be just text)
	Assigner *Reference `json:"assigner,omitempty"`
}

// MarketingStatus represents FHIR MarketingStatus.
type MarketingStatus struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The country in which the marketing authorisation has been granted shall be specified It should be specified using the ISO 3166 ‑ 1 alpha-2 code elements
	Country CodeableConcept `json:"country"`
	// Where a Medicines Regulatory Agency has granted a marketing authorisation for which specific provisions within a jurisdiction apply, the jurisdiction can be specified using an appropriate controlled terminology The controlled term and the controlled term identifier shall be specified
	Jurisdiction *CodeableConcept `json:"jurisdiction,omitempty"`
	// This attribute provides information on the status of the marketing of the medicinal product See ISO/TS 20443 for more information and examples
	Status CodeableConcept `json:"status"`
	// The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain
	DateRange Period `json:"dateRange"`
	// The date when the Medicinal Product is placed on the market by the Marketing Authorisation Holder (or where applicable, the manufacturer/distributor) in a country and/or jurisdiction shall be provided A complete date consisting of day, month and year shall be specified using the ISO 8601 date format NOTE “Placed on the market” refers to the release of the Medicinal Product into the distribution chain
	RestoreDate *string `json:"restoreDate,omitempty"`
}

// Meta represents FHIR Meta.
type Meta struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Version specific identifier
	VersionId *string `json:"versionId,omitempty"`
	// When the resource version last changed
	LastUpdated *string `json:"lastUpdated,omitempty"`
	// Identifies where the resource comes from
	Source *string `json:"source,omitempty"`
	// Profiles this resource claims to conform to
	Profile []string `json:"profile,omitempty"`
	// Security Labels applied to this resource
	Security []Coding `json:"security,omitempty"`
	// Tags applied to this resource
	Tag []Coding `json:"tag,omitempty"`
}

// MetadataResource represents FHIR MetadataResource.
type MetadataResource struct {
	// Logical id of this artifact
	Id *string `json:"id,omitempty"`
	// Metadata about the resource
	Meta *Meta `json:"meta,omitempty"`
	// A set of rules under which this content was created
	ImplicitRules *string `json:"implicitRules,omitempty"`
	// Language of the resource content
	Language *string `json:"language,omitempty"`
	// Text summary of the resource, for human interpretation
	Text *Narrative `json:"text,omitempty"`
	// Contained, inline Resources
	Contained []Resource `json:"contained,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Canonical identifier for this metadata resource, represented as a URI (globally unique)
	Url *string `json:"url,omitempty"`
	// Business version of the metadata resource
	Version *string `json:"version,omitempty"`
	// Name for this metadata resource (computer friendly)
	Name *string `json:"name,omitempty"`
	// Name for this metadata resource (human friendly)
	Title *string `json:"title,omitempty"`
	// draft | active | retired | unknown
	Status *string `json:"status,omitempty"`
	// For testing purposes, not real usage
	Experimental *bool `json:"experimental,omitempty"`
	// Date last changed
	Date *string `json:"date,omitempty"`
	// Name of the publisher (organization or individual)
	Publisher *string `json:"publisher,omitempty"`
	// Contact details for the publisher
	Contact []ContactDetail `json:"contact,omitempty"`
	// Natural language description of the metadata resource
	Description *string `json:"description,omitempty"`
	// The context that the content is intended to support
	UseContext []UsageContext `json:"useContext,omitempty"`
	// Intended jurisdiction for metadata resource (if applicable)
	Jurisdiction []CodeableConcept `json:"jurisdiction,omitempty"`
}

// Money represents FHIR Money.
type Money struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// ISO 4217 Currency Code
	Currency *string `json:"currency,omitempty"`
}

// MoneyQuantity represents FHIR MoneyQuantity.
type MoneyQuantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// Narrative represents FHIR Narrative.
type Narrative struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// generated | extensions | additional | empty
	Status *string `json:"status,omitempty"`
	// Limited xhtml content
	Div *string `json:"div,omitempty"`
}

// ParameterDefinition represents FHIR ParameterDefinition.
type ParameterDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Name used to access the parameter value
	Name *string `json:"name,omitempty"`
	// in | out
	Use *string `json:"use,omitempty"`
	// Minimum cardinality
	Min *int `json:"min,omitempty"`
	// Maximum cardinality (a number of *)
	Max *string `json:"max,omitempty"`
	// A brief description of the parameter
	Documentation *string `json:"documentation,omitempty"`
	// What type of value
	Type *string `json:"type,omitempty"`
	// What profile the value is expected to be
	Profile *string `json:"profile,omitempty"`
}

// Period represents FHIR Period.
type Period struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Starting time with inclusive boundary
	Start *string `json:"start,omitempty"`
	// End time with inclusive boundary, if not ongoing
	End *string `json:"end,omitempty"`
}

// Population represents FHIR Population.
type Population struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// The age of the specific population
	AgeRange *Range `json:"ageRange,omitempty"`
	// The age of the specific population
	AgeCodeableConcept *CodeableConcept `json:"ageCodeableConcept,omitempty"`
	// The gender of the specific population
	Gender *CodeableConcept `json:"gender,omitempty"`
	// Race of the specific population
	Race *CodeableConcept `json:"race,omitempty"`
	// The existing physiological conditions of the specific population to which this applies
	PhysiologicalCondition *CodeableConcept `json:"physiologicalCondition,omitempty"`
}

// ProdCharacteristic represents FHIR ProdCharacteristic.
type ProdCharacteristic struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Where applicable, the height can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Height *Quantity `json:"height,omitempty"`
	// Where applicable, the width can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Width *Quantity `json:"width,omitempty"`
	// Where applicable, the depth can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Depth *Quantity `json:"depth,omitempty"`
	// Where applicable, the weight can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Weight *Quantity `json:"weight,omitempty"`
	// Where applicable, the nominal volume can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	NominalVolume *Quantity `json:"nominalVolume,omitempty"`
	// Where applicable, the external diameter can be specified using a numerical value and its unit of measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	ExternalDiameter *Quantity `json:"externalDiameter,omitempty"`
	// Where applicable, the shape can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Shape *string `json:"shape,omitempty"`
	// Where applicable, the color can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Color []string `json:"color,omitempty"`
	// Where applicable, the imprint can be specified as text
	Imprint []string `json:"imprint,omitempty"`
	// Where applicable, the image can be provided The format of the image attachment shall be specified by regional implementations
	Image []Attachment `json:"image,omitempty"`
	// Where applicable, the scoring can be specified An appropriate controlled vocabulary shall be used The term and the term identifier shall be used
	Scoring *CodeableConcept `json:"scoring,omitempty"`
}

// ProductShelfLife represents FHIR ProductShelfLife.
type ProductShelfLife struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Unique identifier for the packaged Medicinal Product
	Identifier *Identifier `json:"identifier,omitempty"`
	// This describes the shelf life, taking into account various scenarios such as shelf life of the packaged Medicinal Product itself, shelf life after transformation where necessary and shelf life after the first opening of a bottle, etc. The shelf life type shall be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
	Type CodeableConcept `json:"type"`
	// The shelf life time period can be specified using a numerical value for the period of time and its unit of time measurement The unit of measurement shall be specified in accordance with ISO 11240 and the resulting terminology The symbol and the symbol identifier shall be used
	Period Quantity `json:"period"`
	// Special precautions for storage, if any, can be specified using an appropriate controlled vocabulary The controlled term and the controlled term identifier shall be specified
	SpecialPrecautionsForStorage []CodeableConcept `json:"specialPrecautionsForStorage,omitempty"`
}

// Quantity represents FHIR Quantity.
type Quantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// Range represents FHIR Range.
type Range struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Low limit
	Low *Quantity `json:"low,omitempty"`
	// High limit
	High *Quantity `json:"high,omitempty"`
}

// Ratio represents FHIR Ratio.
type Ratio struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerator value
	Numerator *Quantity `json:"numerator,omitempty"`
	// Denominator value
	Denominator *Quantity `json:"denominator,omitempty"`
}

// Reference represents FHIR Reference.
type Reference struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Literal reference, Relative, internal or absolute URL
	Reference *string `json:"reference,omitempty"`
	// Type the reference refers to (e.g. "Patient")
	Type *string `json:"type,omitempty"`
	// Logical reference, when literal reference is not known
	Identifier *Identifier `json:"identifier,omitempty"`
	// Text alternative for the resource
	Display *string `json:"display,omitempty"`
}

// RelatedArtifact represents FHIR RelatedArtifact.
type RelatedArtifact struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// documentation | justification | citation | predecessor | successor | derived-from | depends-on | composed-of
	Type *string `json:"type,omitempty"`
	// Short label
	Label *string `json:"label,omitempty"`
	// Brief description of the related artifact
	Display *string `json:"display,omitempty"`
	// Bibliographic citation for the artifact
	Citation *string `json:"citation,omitempty"`
	// Where the artifact can be accessed
	Url *string `json:"url,omitempty"`
	// What document is being referenced
	Document *Attachment `json:"document,omitempty"`
	// What resource is being referenced
	Resource *string `json:"resource,omitempty"`
}

// SampledData represents FHIR SampledData.
type SampledData struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Zero value and units
	Origin Quantity `json:"origin"`
	// Number of milliseconds between samples
	Period *float64 `json:"period,omitempty"`
	// Multiply data by this before adding to origin
	Factor *float64 `json:"factor,omitempty"`
	// Lower limit of detection
	LowerLimit *float64 `json:"lowerLimit,omitempty"`
	// Upper limit of detection
	UpperLimit *float64 `json:"upperLimit,omitempty"`
	// Number of sample points at each time point
	Dimensions *uint32 `json:"dimensions,omitempty"`
	// Decimal values with spaces, or "E" | "U" | "L"
	Data *string `json:"data,omitempty"`
}

// Signature represents FHIR Signature.
type Signature struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Indication of the reason the entity signed the object(s)
	Type []Coding `json:"type,omitempty"`
	// When the signature was created
	When *string `json:"when,omitempty"`
	// Who signed
	Who Reference `json:"who"`
	// The party represented
	OnBehalfOf *Reference `json:"onBehalfOf,omitempty"`
	// The technical format of the signed resources
	TargetFormat *string `json:"targetFormat,omitempty"`
	// The technical format of the signature
	SigFormat *string `json:"sigFormat,omitempty"`
	// The actual signature content (XML DigSig. JWS, picture, etc.)
	Data *string `json:"data,omitempty"`
}

// SimpleQuantity represents FHIR SimpleQuantity.
type SimpleQuantity struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Numerical value (with implicit precision)
	Value *float64 `json:"value,omitempty"`
	// < | <= | >= | > - how to understand the value
	Comparator *string `json:"comparator,omitempty"`
	// Unit representation
	Unit *string `json:"unit,omitempty"`
	// System that defines coded unit form
	System *string `json:"system,omitempty"`
	// Coded form of the unit
	Code *string `json:"code,omitempty"`
}

// SubstanceAmount represents FHIR SubstanceAmount.
type SubstanceAmount struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field
	AmountQuantity *Quantity `json:"amountQuantity,omitempty"`
	// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field
	AmountRange *Range `json:"amountRange,omitempty"`
	// Used to capture quantitative values for a variety of elements. If only limits are given, the arithmetic mean would be the average. If only a single definite value for a given element is given, it would be captured in this field
	AmountString *string `json:"amountString,omitempty"`
	// Extension for AmountString
	AmountStringExt *Element `json:"_amountString,omitempty"`
	// Most elements that require a quantitative value will also have a field called amount type. Amount type should always be specified because the actual value of the amount is often dependent on it. EXAMPLE: In capturing the actual relative amounts of substances or molecular fragments it is essential to indicate whether the amount refers to a mole ratio or weight ratio. For any given element an effort should be made to use same the amount type for all related definitional elements
	AmountType *CodeableConcept `json:"amountType,omitempty"`
	// A textual comment on a numeric value
	AmountText *string `json:"amountText,omitempty"`
	// Reference range of possible or expected values
	ReferenceRange *Element `json:"referenceRange,omitempty"`
}

// Timing represents FHIR Timing.
type Timing struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Extensions that cannot be ignored even if unrecognized
	ModifierExtension []Extension `json:"modifierExtension,omitempty"`
	// When the event occurs
	Event []string `json:"event,omitempty"`
	// When the event is to occur
	Repeat *Element `json:"repeat,omitempty"`
	// BID | TID | QID | AM | PM | QD | QOD | +
	Code *CodeableConcept `json:"code,omitempty"`
}

// TriggerDefinition represents FHIR TriggerDefinition.
type TriggerDefinition struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// named-event | periodic | data-changed | data-added | data-modified | data-removed | data-accessed | data-access-ended
	Type *string `json:"type,omitempty"`
	// Name or URI that identifies the event
	Name *string `json:"name,omitempty"`
	// Timing of the event
	TimingTiming *Timing `json:"timingTiming,omitempty"`
	// Timing of the event
	TimingReference *Reference `json:"timingReference,omitempty"`
	// Timing of the event
	TimingDate *string `json:"timingDate,omitempty"`
	// Extension for TimingDate
	TimingDateExt *Element `json:"_timingDate,omitempty"`
	// Timing of the event
	TimingDateTime *string `json:"timingDateTime,omitempty"`
	// Extension for TimingDateTime
	TimingDateTimeExt *Element `json:"_timingDateTime,omitempty"`
	// Triggering data of the event (multiple = 'and')
	Data []DataRequirement `json:"data,omitempty"`
	// Whether the event triggers (boolean expression)
	Condition *Expression `json:"condition,omitempty"`
}

// UsageContext represents FHIR UsageContext.
type UsageContext struct {
	// Unique id for inter-element referencing
	Id *string `json:"id,omitempty"`
	// Additional content defined by implementations
	Extension []Extension `json:"extension,omitempty"`
	// Type of context being specified
	Code Coding `json:"code"`
	// Value that defines the context
	ValueCodeableConcept *CodeableConcept `json:"valueCodeableConcept,omitempty"`
	// Value that defines the context
	ValueQuantity *Quantity `json:"valueQuantity,omitempty"`
	// Value that defines the context
	ValueRange *Range `json:"valueRange,omitempty"`
	// Value that defines the context
	ValueReference *Reference `json:"valueReference,omitempty"`
}
