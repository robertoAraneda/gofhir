package generator

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"unicode"

	"github.com/robertoaraneda/gofhir/internal/codegen/analyzer"
)

const kindResource = "resource"

// generateBuilders generates builders.go with Functional Options and Fluent Builders.
func (c *CodeGen) generateBuilders() error {
	var resources []*analyzer.AnalyzedType
	for _, t := range c.types {
		if t.Kind == kindResource {
			resources = append(resources, t)
		}
	}

	if len(resources) == 0 {
		return nil
	}

	// Sort alphabetically
	sort.Slice(resources, func(i, j int) bool {
		return resources[i].Name < resources[j].Name
	})

	var buf bytes.Buffer

	// Write header
	fmt.Fprintf(&buf, "// Code generated by gofhir. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "// Source: FHIR StructureDefinitions (builders)\n")
	fmt.Fprintf(&buf, "// Package: %s\n\n", c.config.PackageName)
	fmt.Fprintf(&buf, "package %s\n\n", c.config.PackageName)

	// Generate builders for each resource
	for _, resource := range resources {
		c.writeResourceBuilders(&buf, resource)
	}

	// Format code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		path := filepath.Join(c.config.OutputDir, "builders.go.unformatted")
		if writeErr := os.WriteFile(path, buf.Bytes(), 0o600); writeErr != nil {
			return fmt.Errorf("format error: %w (also failed to write debug file: %v)", err, writeErr)
		}
		return fmt.Errorf("failed to format builders (saved to %s): %w", path, err)
	}

	path := filepath.Join(c.config.OutputDir, "builders.go")
	return os.WriteFile(path, formatted, 0o600)
}

// writeResourceBuilders writes both Functional Options and Fluent Builder for a resource.
func (c *CodeGen) writeResourceBuilders(buf *bytes.Buffer, t *analyzer.AnalyzedType) {
	lowerName := toLowerFirst(t.Name)

	// Write section header
	fmt.Fprintf(buf, "// =============================================================================\n")
	fmt.Fprintf(buf, "// %s - Functional Options Pattern\n", t.Name)
	fmt.Fprintf(buf, "// =============================================================================\n\n")

	// Write Option type
	fmt.Fprintf(buf, "// %sOption is a functional option for configuring a %s.\n", t.Name, t.Name)
	fmt.Fprintf(buf, "type %sOption func(*%s)\n\n", t.Name, t.Name)

	// Write constructor with options
	fmt.Fprintf(buf, "// New%s creates a new %s with the given options.\n", t.Name, t.Name)
	fmt.Fprintf(buf, "func New%s(opts ...%sOption) *%s {\n", t.Name, t.Name, t.Name)
	fmt.Fprintf(buf, "\tr := &%s{}\n", t.Name)
	fmt.Fprintf(buf, "\tfor _, opt := range opts {\n")
	fmt.Fprintf(buf, "\t\topt(r)\n")
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "\treturn r\n")
	fmt.Fprintf(buf, "}\n\n")

	// Write functional options for each property
	for _, prop := range t.Properties {
		if prop.IsChoice {
			// Handle choice types - generate one option per choice
			c.writeChoiceTypeOptions(buf, t.Name, prop)
		} else {
			c.writeFunctionalOption(buf, t.Name, prop)
		}
	}

	// Write Fluent Builder section
	fmt.Fprintf(buf, "// =============================================================================\n")
	fmt.Fprintf(buf, "// %s - Fluent Builder Pattern\n", t.Name)
	fmt.Fprintf(buf, "// =============================================================================\n\n")

	// Write Builder struct
	fmt.Fprintf(buf, "// %sBuilder provides a fluent API for constructing %s resources.\n", t.Name, t.Name)
	fmt.Fprintf(buf, "type %sBuilder struct {\n", t.Name)
	fmt.Fprintf(buf, "\t%s *%s\n", lowerName, t.Name)
	fmt.Fprintf(buf, "}\n\n")

	// Write constructor
	fmt.Fprintf(buf, "// New%sBuilder creates a new %sBuilder.\n", t.Name, t.Name)
	fmt.Fprintf(buf, "func New%sBuilder() *%sBuilder {\n", t.Name, t.Name)
	fmt.Fprintf(buf, "\treturn &%sBuilder{\n", t.Name)
	fmt.Fprintf(buf, "\t\t%s: &%s{},\n", lowerName, t.Name)
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "}\n\n")

	// Write Build method
	fmt.Fprintf(buf, "// Build returns the constructed %s resource.\n", t.Name)
	fmt.Fprintf(buf, "func (b *%sBuilder) Build() *%s {\n", t.Name, t.Name)
	fmt.Fprintf(buf, "\treturn b.%s\n", lowerName)
	fmt.Fprintf(buf, "}\n\n")

	// Write builder methods for each property
	for _, prop := range t.Properties {
		if prop.IsChoice {
			c.writeChoiceTypeBuilderMethods(buf, t.Name, lowerName, prop)
		} else {
			c.writeBuilderMethod(buf, t.Name, lowerName, prop)
		}
	}
}

// writeFunctionalOption writes a single functional option for a property.
func (c *CodeGen) writeFunctionalOption(buf *bytes.Buffer, resourceName string, prop analyzer.AnalyzedProperty) {
	optionName := fmt.Sprintf("With%s%s", resourceName, prop.Name)

	// Skip content references (*interface{}) - they are not properly typed
	if prop.GoType == "*interface{}" {
		return
	}

	switch {
	case prop.IsArray:
		// For arrays, generate Add function
		optionName = fmt.Sprintf("With%s%s", resourceName, prop.Name)
		elementType := strings.TrimPrefix(prop.GoType, "[]")

		fmt.Fprintf(buf, "// %s adds a %s to the %s.\n", optionName, prop.Name, resourceName)
		fmt.Fprintf(buf, "func %s(v %s) %sOption {\n", optionName, elementType, resourceName)
		fmt.Fprintf(buf, "\treturn func(r *%s) {\n", resourceName)
		fmt.Fprintf(buf, "\t\tr.%s = append(r.%s, v)\n", prop.Name, prop.Name)
		fmt.Fprintf(buf, "\t}\n")
		fmt.Fprintf(buf, "}\n\n")
	case prop.IsPointer:
		// For pointer fields, take value and set pointer
		baseType := strings.TrimPrefix(prop.GoType, "*")

		fmt.Fprintf(buf, "// %s sets the %s field.\n", optionName, prop.Name)
		fmt.Fprintf(buf, "func %s(v %s) %sOption {\n", optionName, baseType, resourceName)
		fmt.Fprintf(buf, "\treturn func(r *%s) {\n", resourceName)
		fmt.Fprintf(buf, "\t\tr.%s = &v\n", prop.Name)
		fmt.Fprintf(buf, "\t}\n")
		fmt.Fprintf(buf, "}\n\n")
	default:
		// For non-pointer fields, set directly
		fmt.Fprintf(buf, "// %s sets the %s field.\n", optionName, prop.Name)
		fmt.Fprintf(buf, "func %s(v %s) %sOption {\n", optionName, prop.GoType, resourceName)
		fmt.Fprintf(buf, "\treturn func(r *%s) {\n", resourceName)
		fmt.Fprintf(buf, "\t\tr.%s = v\n", prop.Name)
		fmt.Fprintf(buf, "\t}\n")
		fmt.Fprintf(buf, "}\n\n")
	}
}

// writeChoiceTypeOptions writes functional options for choice type properties.
func (c *CodeGen) writeChoiceTypeOptions(buf *bytes.Buffer, resourceName string, prop analyzer.AnalyzedProperty) {
	// For choice types, the property name already includes the type (e.g., ValueQuantity)
	optionName := fmt.Sprintf("With%s%s", resourceName, prop.Name)
	baseType := strings.TrimPrefix(prop.GoType, "*")

	fmt.Fprintf(buf, "// %s sets the %s choice type field.\n", optionName, prop.Name)
	fmt.Fprintf(buf, "func %s(v %s) %sOption {\n", optionName, baseType, resourceName)
	fmt.Fprintf(buf, "\treturn func(r *%s) {\n", resourceName)
	if prop.IsPointer {
		fmt.Fprintf(buf, "\t\tr.%s = &v\n", prop.Name)
	} else {
		fmt.Fprintf(buf, "\t\tr.%s = v\n", prop.Name)
	}
	fmt.Fprintf(buf, "\t}\n")
	fmt.Fprintf(buf, "}\n\n")
}

// writeBuilderMethod writes a single builder method for a property.
func (c *CodeGen) writeBuilderMethod(buf *bytes.Buffer, resourceName, lowerName string, prop analyzer.AnalyzedProperty) {
	// Skip content references (*interface{}) - they are not properly typed
	if prop.GoType == "*interface{}" {
		return
	}

	switch {
	case prop.IsArray:
		// For arrays, generate Add method
		methodName := fmt.Sprintf("Add%s", prop.Name)
		elementType := strings.TrimPrefix(prop.GoType, "[]")

		fmt.Fprintf(buf, "// %s adds a %s element.\n", methodName, prop.Name)
		fmt.Fprintf(buf, "func (b *%sBuilder) %s(v %s) *%sBuilder {\n", resourceName, methodName, elementType, resourceName)
		fmt.Fprintf(buf, "\tb.%s.%s = append(b.%s.%s, v)\n", lowerName, prop.Name, lowerName, prop.Name)
		fmt.Fprintf(buf, "\treturn b\n")
		fmt.Fprintf(buf, "}\n\n")
	case prop.IsPointer:
		// For pointer fields, generate Set method that takes value
		methodName := fmt.Sprintf("Set%s", prop.Name)
		baseType := strings.TrimPrefix(prop.GoType, "*")

		fmt.Fprintf(buf, "// %s sets the %s field.\n", methodName, prop.Name)
		fmt.Fprintf(buf, "func (b *%sBuilder) %s(v %s) *%sBuilder {\n", resourceName, methodName, baseType, resourceName)
		fmt.Fprintf(buf, "\tb.%s.%s = &v\n", lowerName, prop.Name)
		fmt.Fprintf(buf, "\treturn b\n")
		fmt.Fprintf(buf, "}\n\n")
	default:
		// For non-pointer fields, generate Set method
		methodName := fmt.Sprintf("Set%s", prop.Name)

		fmt.Fprintf(buf, "// %s sets the %s field.\n", methodName, prop.Name)
		fmt.Fprintf(buf, "func (b *%sBuilder) %s(v %s) *%sBuilder {\n", resourceName, methodName, prop.GoType, resourceName)
		fmt.Fprintf(buf, "\tb.%s.%s = v\n", lowerName, prop.Name)
		fmt.Fprintf(buf, "\treturn b\n")
		fmt.Fprintf(buf, "}\n\n")
	}
}

// writeChoiceTypeBuilderMethods writes builder methods for choice type properties.
func (c *CodeGen) writeChoiceTypeBuilderMethods(buf *bytes.Buffer, resourceName, lowerName string, prop analyzer.AnalyzedProperty) {
	// For choice types, the property name already includes the type (e.g., ValueQuantity)
	methodName := fmt.Sprintf("Set%s", prop.Name)
	baseType := strings.TrimPrefix(prop.GoType, "*")

	fmt.Fprintf(buf, "// %s sets the %s choice type field.\n", methodName, prop.Name)
	fmt.Fprintf(buf, "func (b *%sBuilder) %s(v %s) *%sBuilder {\n", resourceName, methodName, baseType, resourceName)
	if prop.IsPointer {
		fmt.Fprintf(buf, "\tb.%s.%s = &v\n", lowerName, prop.Name)
	} else {
		fmt.Fprintf(buf, "\tb.%s.%s = v\n", lowerName, prop.Name)
	}
	fmt.Fprintf(buf, "\treturn b\n")
	fmt.Fprintf(buf, "}\n\n")
}

// toLowerFirst converts the first character to lowercase.
func toLowerFirst(s string) string {
	if s == "" {
		return ""
	}
	runes := []rune(s)
	runes[0] = unicode.ToLower(runes[0])
	return string(runes)
}
